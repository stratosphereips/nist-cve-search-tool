#!/usr/bin/env python3
# Author: Lisandro Ubiedo, @_lubiedo
# Organization: Stratosphere Research Laboratory
# Maintainer: Veronica Valeros, @verovaleros

import os
import re
import gzip
import json
import argparse
import requests

args = None
short = None
count = -1

CVEs = list()


class bcolors:
    """
    https://stackoverflow.com/questions/287871/how-to-print-colored-text-in-python#287944
    """
    c = {
        'BLUE': '\033[94m',
        'LOW': '\033[92m',
        'MEDIUM': '\033[93m',
        'HIGH': '\033[91m',
        'CRITICAL': '\033[95m',
        'ENDC': '\033[0m',
        'BOLD': '\033[1m',
        'UNDERLINE': '\033[4m'
    }

    def h(s):
        return f"{bcolors.c['BOLD']}{s}:{bcolors.c['ENDC']}"

    def cseverity(s):
        if s in bcolors.c:
            return bcolors.c[s]
        bcolors.c['BOLD']


def shorten():
    """
    shorten() will output a simple description of the CVEs found
    instead of the default JSON formatted output.
    """
    i = len(CVEs)

    if i == 0:
        print("No CVEs found")
        return

    for entry in CVEs:
        print(f'''
{bcolors.h('ID')} {
    bcolors.c['UNDERLINE']}{entry['cve']['CVE_data_meta']['ID']}{
        bcolors.c['ENDC']}
{bcolors.h('DATE')} {entry['publishedDate']}
{bcolors.h('IMPACT')}''')
        if 'baseMetricV3' in entry['impact']:
            severity = \
                    entry['impact']['baseMetricV3']['cvssV3']['baseSeverity']
            print(f'''    Base Score: {bcolors.cseverity(severity)}{
        entry['impact']['baseMetricV3']['cvssV3']['baseScore']}{
            bcolors.c['ENDC']}
    Severity: {bcolors.cseverity(severity)}{severity}{bcolors.c['ENDC']}
    Vector: {entry['impact']['baseMetricV3']['cvssV3']['vectorString']}''')
        else:
            print('''    Undefined.''')
        print(f'''
{bcolors.h('DESC')} {entry['cve']['description']['description_data'][0]['value']}''')
        i -= 1
        if i > 0:
            print("---")


def search(data_json: object, search_query: str, in_decription: bool = False):
    """
    This function parses the NIST JSON data,
    identifies each CVE, and searches for the
    given query on each of the CVE description.
    """
    # The user can specify the maximum results to retrieve
    # This is stored in the global variable: count
    max_results_counter = 0

    # Create the regex to search for the query on the data
    regex = re.compile(f'({search_query})', re.I)

    for entry in data_json['CVE_Items']:
        # Filter for CVE entries
        # use CPE entries
        if ('configurations' in entry and
                len(entry['configurations']['nodes']) > 0):
            found = False
            for node in entry['configurations']['nodes']:
                for cpe in node['cpe_match']:
                    if regex.search(cpe['cpe23Uri']) is not None:
                        CVEs.append(entry)
                        max_results_counter += 1
                        found = True
                        break
            if found:
                # if item found already using CPE entry then continue
                continue

        # use the description as search data
        if 'cve' in entry and in_decription:
            # Obtain CVE description
            cve_description = entry['cve']['description']
            # Process each description data?
            for d in cve_description['description_data']:
                # Find the first match of search query regex
                # in the CVE description data retrieved
                if regex.search(d['value']) is not None:
                    CVEs.append(entry)
                    max_results_counter += 1
                    break
        # If the maximum results are reached, exit
        if max_results_counter == count:
            break

    if short:
        shorten()


def download_nist_data(year: int) -> object:
    """
    Donwload NIST CVE data for a given year
    """
    try:
        data_path = f"{os.getcwd()}/data"
        data_file = f"{data_path}/nvdcve-1.1-{year}.json.gz"
        data_url = f"https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-{str(year)}.json.gz"

        # Download NIST data for a given year
        content = requests.get(data_url, headers={"Accept-Encoding": "gzip"})

        # If download was not successful raise exception
        if content.status_code != 200:
            raise Exception("Error requesting compressed NIST JSON.")

        # If download was successful
        # First, save it locally
        open(data_file, 'wb').write(content.content)

        # Second, load it as JSON
        try:
            data = json.loads(gzip.decompress(content.content))
        except json.decoder.JSONDecodeError as err:
            raise Exception(f"Error decoding NIST JSON: {err}")

        return data

    except Exception as err:
        print(f"Exception in download_nist_data: {err}")
        return None


def retrieve_nist_data_from_cache(year: int) -> object:
    """
    Check local cache if NIST data for a given
    year already exists. If yes, use it.
    """
    try:
        data_file = "nvdcve-1.1-{YEAR}.json.gz"
        data_path = f"{os.getcwd()}/data"

        # NIST file for the year we are searching
        nist_file = f"{data_path}/{data_file.replace('{YEAR}', str(year))}"

        # Check if file exists in path
        if os.path.exists(nist_file) and os.path.getsize(nist_file) > 30000:
            with gzip.open(nist_file, 'rb') as nist_data:
                try:
                    return json.loads(nist_data.read())
                except json.decoder.JSONDecodeError as err:
                    raise Exception(f"Error decoding NIST JSON: {err}")

        # In any other case, return false
        return None
    except Exception as err:
        print(f"Exception in retrieve_nist_data_from_cache: {err}")


def main():
    global args, short, count

    # Parse arguments
    parser = argparse.ArgumentParser(description="Search CVEs on NIST data")
    parser.add_argument('-s', '--short', default=False,
                        help="Print short version of each CVE entry",
                        action='store_true')
    parser.add_argument('-d', '--search-description', default=False,
                        action='store_true',
                        help='Search in CVE description too')
    parser.add_argument('-y', '--year', required=True, type=str,
                        help="Year to look for. Examples: '2020' (single) \
                        or '2019,2020' (list) or '2010-2020' (range)")
    parser.add_argument('-c', '--count', type=int,
                        help="Number of results to display")
    parser.add_argument('search', type=str, help="Search query, regex capable")
    args = parser.parse_args()

    short = args.short
    count = args.count
    search_years = None

    # The number of years could be provided in three formats:
    # 1 - Single year: 2011
    # 2 - Sequence of years: 2011,2012,2013
    # 3 - Range of years: 2010-2014
    try:
        # Parse range of years, e.g.: 2010-2014
        if args.year.index('-') == 4:
            (year_min, year_max) = args.year.split('-')
            search_years = range(int(year_min), int(year_max)+1)
        else:
            parser.print_help()
            quit(1)
    except Exception:
        # Parse sequence of years, e.g.: 2011,2012,2013
        search_years = args.year.split(',')

    # Search for CVE for every year
    for year in search_years:
        # Attempting to retrieve data from local cache
        nist_data = retrieve_nist_data_from_cache(year)
        if not nist_data:
            # If no local cache found, download NIST data for a given year
            nist_data = download_nist_data(year)

        # Search in the downloaded data
        if nist_data:
            search(nist_data, args.search, args.search_description)
        else:
            print("Error retrieving NIST data {nist_data}")

    if not short:
        print(json.dumps(CVEs))


if __name__ == '__main__':
    main()
